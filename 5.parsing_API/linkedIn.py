# Q2
# Assume there is a REST API available at "http://www.linkedin.corp/api" for accessing employee information. The employee information endpoint is "/employee/<id>". Each employee record you retrieve will be a JSON object with the following keys:

#   - 'name'  refers to a String that contains the employee's first and last name

#   - 'title' refers to a String that contains the employee's job title

#   - 'reports' refers to an Array of Strings containing the IDs of the employee's direct reports


# Sample JSON API Response:

# # GET /employee/A123456789
# {
#  "name": "Flynn Mackie",
#  "title": "Senior VP of Engineering",
#  "reports": ["A123456793", "A1234567898"]
# }
# Write a function that will take an employee ID and print out the entire hierarchy, rooted at that employee, and including all employees under that employee.

# For example, suppose that Flynn Mackie's employee id is 'A123456789' and his only direct reports are Wesley Thomas and Nina Chiswick. If you provide 'A123456789' as input to your function, you will see the sample output below.


# -----------Begin Sample Output--------------
# Flynn Mackie - Senior VP of Engineering
#   Wesley Thomas - VP of Design
#     Randall Cosmo - Director of Design
#       Brenda Plager - Senior Designer
#   Nina Chiswick - VP of Engineering
#     Tommy Quinn - Director of Engineering
#       Jake Farmer - Frontend Manager
#         Liam Freeman - Junior Software Engineer
#       Sheila Dunbar - Backend Manager
#         Peter Young - Senior Code Cowboy
# -----------End Sample Output--------------

import requests
from requests.exceptions import HTTPError

class Employee:
    def __init__(self, name, title, reports):
        self.name = name
        self.title = title
        self.reports = reports

    def api_fetcher(self, id):
        try:
            response = requests.get('http://www.linkedin.corp/api/employee/{}'.format(id))
            response.raise_for_status()
        except HTTPError as http_err:
            print(f'HTTP error occurred: {http_err}')
        except Exception as err:
            print(f'Other error occurred: {err}')
        else:
            return response.json()

    def print_hierarchy(self, id):
        employee = self.api_fetcher(id)
        print(employee['name'] + ' - ' + employee['title'])
        for report in employee['reports']:
            self.print_hierarchy(report) # recursive function to print hierarchy

def main():
    employee = Employee('', '', [])
    employee.print_hierarchy('A123456789') # call print_hierarchy function

if __name__ == '__main__':
    main()

#######################################################################################
# Q3
"""
Below, see a sample of /var/log/messages.

---------- begin sample log extract ----------
Jan 20 03:25:08 fakehost logrotate: ALERT exited abnormally with [1]
Jan 20 03:25:09 fakehost run-parts(/etc/cron.daily)[20447]: finished logrotate
Jan 20 03:26:21 fakehost anacron[28969]: Job 'cron.daily' terminated
Jan 20 03:26:22 fakehost anacron[28969]: Normal exit (1 job run)
Jan 20 03:30:01 fakehost CROND[31462]: (root) CMD (/usr/lib64/sa/sa1 1 1)
Jan 20 03:30:01 fakehost CROND[31461]: (root) CMD (/var/system/bin/sys-cmd -F > /dev/null 2>&1)
Jan 20 05:03:03 fakehost ntpd[3705]: synchronized to time.faux.biz, stratum 2
Jan 20 05:20:01 fakehost rsyslogd: [origin software="rsyslogd" swVersion="5.8.10" x-pid="20438" x-info="http://www.rsyslog.com"] start
Jan 20 05:22:04 fakehost cs3[31163]:  Q: ".../bin/rsync -LD ": symlink has no referent: "/var/syscmds/fakehost/runit_scripts/etc/runit/service/superImportantService/run"#012Q: ".../bin/rsync -LD ": rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1039) [sender=3.0.6]
Jan 20 05:22:04 fakehost cs3[31163]:  I: Last 2 quoted lines were generated by "/usr/local/bin/rsync -LD --recursive --delete --password-file=/var/syscmds/modules/rsync_password /var/syscmds/fakehost syscmds@fakehost::syscmds_rsync"
Jan 20 05:22:08 fakehost cs3[31163]:  Q: ".../sbin/sv restart": ok: run: /export/service/cool-service: (pid 32323) 0s
Jan 20 05:22:08 fakehost cs3[31163]:  I: Last 1 quoted lines were generated by "/sbin/sv restart /export/service/cool-service"
Jan 20 05:22:09 fakehost cs3[31163]:  R: cs3:  The cool service on fakehost does not appear to be communicating with the cool service leader.  Automating a restart of the cool service in attempt to resolve the communication problem.
Jan 20 05:22:37 fakehost ACCT_ADD: WARNING: Manifest /var/syscmds/inputs/config-general/doit.txt has been processed already, bailing
---------- end sample log extract ----------


Write a script which parses /var/log/messages and generates a CSV with two columns: minute, number_of_messages in sorted time order.

---------- begin sample output ----------
minute,number_of_messages
Jan 20 03:25,2
Jan 20 03:26,2
Jan 20 03:30,2
Jan 20 05:03,1
Jan 20 05:20,1
Jan 20 05:22,6
"""

import csv

class LogParser(object):
    def __init__(self, log_file):
        self.log_file = log_file 
        self.log_dict = {} 

    def parse_log(self):
        with open(self.log_file, 'r') as f:
            for line in f:
                line_split = line.split() # split the line into a list
                if len(line_split) > 1: # if the line has more than one word
                    timestamp = line_split[0] # get the first word
                    minute = timestamp[:13] # get the first 13 characters # Jan 20 03:25:08
                    if minute not in self.log_dict: # if the minute is not in the log_dict
                        self.log_dict[minute] = 1 # add the minute to the log_dict with a value of 1
                    else:
                        self.log_dict[minute] += 1 # increment the value of the minute in the log_dict
        return self.log_dict

    def write_csv(self, csv_file):
        with open(csv_file, 'w') as f:
            writer = csv.writer(f) # create a csv.writer
            for minute, number_of_messages in sorted(self.log_dict.items()): #  sorted(self.log_dict.items())
                writer.writerow([minute, number_of_messages])# write the minute and number_of_messages to the csv
def main():
    log_parser = LogParser('/var/log/messages')
    log_parser.write_csv('/tmp/log_parser.csv')

if __name__ == '__main__':
    main()